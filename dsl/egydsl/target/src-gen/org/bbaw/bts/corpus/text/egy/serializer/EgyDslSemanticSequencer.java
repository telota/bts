/*
 * generated by Xtext
 */
package org.bbaw.bts.corpus.text.egy.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.bbaw.bts.corpus.text.egy.egyDsl.Ambivalence;
import org.bbaw.bts.corpus.text.egy.egyDsl.AncientExpanded;
import org.bbaw.bts.corpus.text.egy.egyDsl.AncientExpandedMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.BrokenVersbreakMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Case;
import org.bbaw.bts.corpus.text.egy.egyDsl.Chars;
import org.bbaw.bts.corpus.text.egy.egyDsl.DeletedVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Deletion;
import org.bbaw.bts.corpus.text.egy.egyDsl.DestroyedVersFrontierMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.DestroyedVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.DestructionMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.DisputableReading;
import org.bbaw.bts.corpus.text.egy.egyDsl.DisputableVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.EgyDslPackage;
import org.bbaw.bts.corpus.text.egy.egyDsl.Emendation;
import org.bbaw.bts.corpus.text.egy.egyDsl.EmendationVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Expanded;
import org.bbaw.bts.corpus.text.egy.egyDsl.ExpandedColumn;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixCompoundWords;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixConnectionSyllabicGroup;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixFlexion;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixLexical;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixPhoneticalComplement;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixPrefixLexical;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixPrefixNonLexical;
import org.bbaw.bts.corpus.text.egy.egyDsl.InterfixSuffixPronomLexical;
import org.bbaw.bts.corpus.text.egy.egyDsl.Lacuna;
import org.bbaw.bts.corpus.text.egy.egyDsl.Marker;
import org.bbaw.bts.corpus.text.egy.egyDsl.MissingVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Oval;
import org.bbaw.bts.corpus.text.egy.egyDsl.PartialDestroyedVersMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.PartialDestruction;
import org.bbaw.bts.corpus.text.egy.egyDsl.Rasur;
import org.bbaw.bts.corpus.text.egy.egyDsl.RestorationOverRasur;
import org.bbaw.bts.corpus.text.egy.egyDsl.RestorationOverRasurMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Sentence;
import org.bbaw.bts.corpus.text.egy.egyDsl.Serech;
import org.bbaw.bts.corpus.text.egy.egyDsl.TextContent;
import org.bbaw.bts.corpus.text.egy.egyDsl.VersFrontierMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.VersbreakMarker;
import org.bbaw.bts.corpus.text.egy.egyDsl.Word;
import org.bbaw.bts.corpus.text.egy.egyDsl.WordPart;
import org.bbaw.bts.corpus.text.egy.services.EgyDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EgyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EgyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EgyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EgyDslPackage.AMBIVALENCE:
				sequence_Ambivalence(context, (Ambivalence) semanticObject); 
				return; 
			case EgyDslPackage.ANCIENT_EXPANDED:
				sequence_AncientExpanded(context, (AncientExpanded) semanticObject); 
				return; 
			case EgyDslPackage.ANCIENT_EXPANDED_MARKER:
				sequence_AncientExpandedMarker_RasurMarker(context, (AncientExpandedMarker) semanticObject); 
				return; 
			case EgyDslPackage.BROKEN_VERSBREAK_MARKER:
				sequence_BrokenVersbreakMarker(context, (BrokenVersbreakMarker) semanticObject); 
				return; 
			case EgyDslPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case EgyDslPackage.CHARS:
				sequence_Chars(context, (Chars) semanticObject); 
				return; 
			case EgyDslPackage.DELETED_VERS_MARKER:
				sequence_DeletedVersMarker(context, (DeletedVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.DELETION:
				sequence_Deletion(context, (Deletion) semanticObject); 
				return; 
			case EgyDslPackage.DESTROYED_VERS_FRONTIER_MARKER:
				sequence_DestroyedVersFrontierMarker(context, (DestroyedVersFrontierMarker) semanticObject); 
				return; 
			case EgyDslPackage.DESTROYED_VERS_MARKER:
				sequence_DestroyedVersMarker(context, (DestroyedVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.DESTRUCTION_MARKER:
				sequence_DestructionMarker(context, (DestructionMarker) semanticObject); 
				return; 
			case EgyDslPackage.DISPUTABLE_READING:
				sequence_DisputableReading(context, (DisputableReading) semanticObject); 
				return; 
			case EgyDslPackage.DISPUTABLE_VERS_MARKER:
				sequence_DisputableVersMarker(context, (DisputableVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.EMENDATION:
				sequence_Emendation(context, (Emendation) semanticObject); 
				return; 
			case EgyDslPackage.EMENDATION_VERS_MARKER:
				sequence_EmendationVersMarker(context, (EmendationVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.EXPANDED:
				if (rule == grammarAccess.getCartoucheRule()) {
					sequence_Cartouche(context, (Expanded) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWordMiddleRule()
						|| rule == grammarAccess.getBracketsRule()
						|| rule == grammarAccess.getNoLacunaRule()
						|| rule == grammarAccess.getNoRestorationOverRasurRule()
						|| rule == grammarAccess.getNoPartialDestructionRule()) {
					sequence_Cartouche_Expanded(context, (Expanded) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNoCartoucheRule()
						|| rule == grammarAccess.getExpandedRule()
						|| rule == grammarAccess.getNoEmendationRule()
						|| rule == grammarAccess.getNoDisputableReadingRule()
						|| rule == grammarAccess.getNoDeletionRule()
						|| rule == grammarAccess.getNoExpandedColumnRule()
						|| rule == grammarAccess.getNoRasurRule()
						|| rule == grammarAccess.getNoAncientExpandedRule()) {
					sequence_Expanded(context, (Expanded) semanticObject); 
					return; 
				}
				else break;
			case EgyDslPackage.EXPANDED_COLUMN:
				sequence_ExpandedColumn(context, (ExpandedColumn) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_COMPOUND_WORDS:
				sequence_InterfixCompoundWords(context, (InterfixCompoundWords) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_CONNECTION_SYLLABIC_GROUP:
				sequence_InterfixConnectionSyllabicGroup(context, (InterfixConnectionSyllabicGroup) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_FLEXION:
				sequence_InterfixFlexion(context, (InterfixFlexion) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_LEXICAL:
				sequence_InterfixLexical(context, (InterfixLexical) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_PHONETICAL_COMPLEMENT:
				sequence_InterfixPhoneticalComplement(context, (InterfixPhoneticalComplement) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_PREFIX_LEXICAL:
				sequence_InterfixPrefixLexical(context, (InterfixPrefixLexical) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_PREFIX_NON_LEXICAL:
				sequence_InterfixPrefixNonLexical(context, (InterfixPrefixNonLexical) semanticObject); 
				return; 
			case EgyDslPackage.INTERFIX_SUFFIX_PRONOM_LEXICAL:
				sequence_InterfixSuffixPronomLexical(context, (InterfixSuffixPronomLexical) semanticObject); 
				return; 
			case EgyDslPackage.LACUNA:
				sequence_Lacuna(context, (Lacuna) semanticObject); 
				return; 
			case EgyDslPackage.MARKER:
				sequence_Marker(context, (Marker) semanticObject); 
				return; 
			case EgyDslPackage.MISSING_VERS_MARKER:
				sequence_MissingVersMarker(context, (MissingVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.OVAL:
				sequence_Oval(context, (Oval) semanticObject); 
				return; 
			case EgyDslPackage.PARTIAL_DESTROYED_VERS_MARKER:
				sequence_PartialDestroyedVersMarker(context, (PartialDestroyedVersMarker) semanticObject); 
				return; 
			case EgyDslPackage.PARTIAL_DESTRUCTION:
				sequence_PartialDestruction(context, (PartialDestruction) semanticObject); 
				return; 
			case EgyDslPackage.RASUR:
				sequence_Rasur(context, (Rasur) semanticObject); 
				return; 
			case EgyDslPackage.RESTORATION_OVER_RASUR:
				sequence_RestorationOverRasur(context, (RestorationOverRasur) semanticObject); 
				return; 
			case EgyDslPackage.RESTORATION_OVER_RASUR_MARKER:
				sequence_RestorationOverRasurMarker(context, (RestorationOverRasurMarker) semanticObject); 
				return; 
			case EgyDslPackage.SENTENCE:
				sequence_Sentence(context, (Sentence) semanticObject); 
				return; 
			case EgyDslPackage.SERECH:
				sequence_Serech(context, (Serech) semanticObject); 
				return; 
			case EgyDslPackage.TEXT_CONTENT:
				sequence_TextContent(context, (TextContent) semanticObject); 
				return; 
			case EgyDslPackage.VERS_FRONTIER_MARKER:
				sequence_VersFrontierMarker(context, (VersFrontierMarker) semanticObject); 
				return; 
			case EgyDslPackage.VERSBREAK_MARKER:
				sequence_VersbreakMarker(context, (VersbreakMarker) semanticObject); 
				return; 
			case EgyDslPackage.WORD:
				sequence_Word(context, (Word) semanticObject); 
				return; 
			case EgyDslPackage.WORD_PART:
				sequence_WordPart(context, (WordPart) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SentenceItem returns Ambivalence
	 *     Ambivalence returns Ambivalence
	 *
	 * Constraint:
	 *     (cases+=Case cases+=Case+)
	 */
	protected void sequence_Ambivalence(ISerializationContext context, Ambivalence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns AncientExpandedMarker
	 *     AbstractMarker returns AncientExpandedMarker
	 *     SentenceItemNoAmbivalence returns AncientExpandedMarker
	 *     VersMarker returns AncientExpandedMarker
	 *     AncientExpandedMarker returns AncientExpandedMarker
	 *     RasurMarker returns AncientExpandedMarker
	 *
	 * Constraint:
	 *     {AncientExpandedMarker}
	 */
	protected void sequence_AncientExpandedMarker_RasurMarker(ISerializationContext context, AncientExpandedMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns AncientExpanded
	 *     Brackets returns AncientExpanded
	 *     NoCartouche returns AncientExpanded
	 *     AncientExpanded returns AncientExpanded
	 *     NoDisputableReading returns AncientExpanded
	 *     NoDeletion returns AncientExpanded
	 *
	 * Constraint:
	 *     wChar+=NoAncientExpanded+
	 */
	protected void sequence_AncientExpanded(ISerializationContext context, AncientExpanded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns BrokenVersbreakMarker
	 *     AbstractMarker returns BrokenVersbreakMarker
	 *     SentenceItemNoAmbivalence returns BrokenVersbreakMarker
	 *     VersMarker returns BrokenVersbreakMarker
	 *     BrokenVersbreakMarker returns BrokenVersbreakMarker
	 *
	 * Constraint:
	 *     {BrokenVersbreakMarker}
	 */
	protected void sequence_BrokenVersbreakMarker(ISerializationContext context, BrokenVersbreakMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cartouche returns Expanded
	 *
	 * Constraint:
	 *     wChar+=NoCartouche+
	 */
	protected void sequence_Cartouche(ISerializationContext context, Expanded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Expanded
	 *     Brackets returns Expanded
	 *     NoLacuna returns Expanded
	 *     NoRestorationOverRasur returns Expanded
	 *     NoPartialDestruction returns Expanded
	 *
	 * Constraint:
	 *     (wChar+=NoCartouche+ | wChar+=NoExpanded+)
	 */
	protected void sequence_Cartouche_Expanded(ISerializationContext context, Expanded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (name=CASESTRING items+=SentenceItemNoAmbivalence items+=SentenceItemNoAmbivalence*)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Chars
	 *     Chars returns Chars
	 *     NoCartouche returns Chars
	 *     NoExpanded returns Chars
	 *     NoEmendation returns Chars
	 *     NoDisputableReading returns Chars
	 *     NoLacuna returns Chars
	 *     NoDeletion returns Chars
	 *     NoExpandedColumn returns Chars
	 *     NoRasur returns Chars
	 *     NoAncientExpanded returns Chars
	 *     NoRestorationOverRasur returns Chars
	 *     NoPartialDestruction returns Chars
	 *
	 * Constraint:
	 *     name=EGYSTRING
	 */
	protected void sequence_Chars(ISerializationContext context, Chars semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EgyDslPackage.Literals.CHARS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EgyDslPackage.Literals.CHARS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharsAccess().getNameEGYSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns DeletedVersMarker
	 *     AbstractMarker returns DeletedVersMarker
	 *     SentenceItemNoAmbivalence returns DeletedVersMarker
	 *     VersMarker returns DeletedVersMarker
	 *     DeletedVersMarker returns DeletedVersMarker
	 *
	 * Constraint:
	 *     {DeletedVersMarker}
	 */
	protected void sequence_DeletedVersMarker(ISerializationContext context, DeletedVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Deletion
	 *     Brackets returns Deletion
	 *     NoCartouche returns Deletion
	 *     NoDisputableReading returns Deletion
	 *     NoLacuna returns Deletion
	 *     Deletion returns Deletion
	 *     NoExpandedColumn returns Deletion
	 *     NoRasur returns Deletion
	 *     NoAncientExpanded returns Deletion
	 *     NoRestorationOverRasur returns Deletion
	 *     NoPartialDestruction returns Deletion
	 *
	 * Constraint:
	 *     wChar+=NoDeletion+
	 */
	protected void sequence_Deletion(ISerializationContext context, Deletion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns DestroyedVersFrontierMarker
	 *     AbstractMarker returns DestroyedVersFrontierMarker
	 *     SentenceItemNoAmbivalence returns DestroyedVersFrontierMarker
	 *     VersMarker returns DestroyedVersFrontierMarker
	 *     DestroyedVersFrontierMarker returns DestroyedVersFrontierMarker
	 *
	 * Constraint:
	 *     {DestroyedVersFrontierMarker}
	 */
	protected void sequence_DestroyedVersFrontierMarker(ISerializationContext context, DestroyedVersFrontierMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns DestroyedVersMarker
	 *     AbstractMarker returns DestroyedVersMarker
	 *     SentenceItemNoAmbivalence returns DestroyedVersMarker
	 *     VersMarker returns DestroyedVersMarker
	 *     DestroyedVersMarker returns DestroyedVersMarker
	 *
	 * Constraint:
	 *     {DestroyedVersMarker}
	 */
	protected void sequence_DestroyedVersMarker(ISerializationContext context, DestroyedVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns DestructionMarker
	 *     AbstractMarker returns DestructionMarker
	 *     SentenceItemNoAmbivalence returns DestructionMarker
	 *     DestructionMarker returns DestructionMarker
	 *
	 * Constraint:
	 *     type=BETWEEN_MINUS
	 */
	protected void sequence_DestructionMarker(ISerializationContext context, DestructionMarker semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EgyDslPackage.Literals.DESTRUCTION_MARKER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EgyDslPackage.Literals.DESTRUCTION_MARKER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDestructionMarkerAccess().getTypeBETWEEN_MINUSTerminalRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns DisputableReading
	 *     Brackets returns DisputableReading
	 *     NoCartouche returns DisputableReading
	 *     NoExpanded returns DisputableReading
	 *     NoEmendation returns DisputableReading
	 *     DisputableReading returns DisputableReading
	 *     NoLacuna returns DisputableReading
	 *     NoDeletion returns DisputableReading
	 *     NoExpandedColumn returns DisputableReading
	 *     NoRasur returns DisputableReading
	 *     NoAncientExpanded returns DisputableReading
	 *     NoRestorationOverRasur returns DisputableReading
	 *     NoPartialDestruction returns DisputableReading
	 *
	 * Constraint:
	 *     wChar+=NoDisputableReading+
	 */
	protected void sequence_DisputableReading(ISerializationContext context, DisputableReading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns DisputableVersMarker
	 *     AbstractMarker returns DisputableVersMarker
	 *     SentenceItemNoAmbivalence returns DisputableVersMarker
	 *     VersMarker returns DisputableVersMarker
	 *     DisputableVersMarker returns DisputableVersMarker
	 *
	 * Constraint:
	 *     {DisputableVersMarker}
	 */
	protected void sequence_DisputableVersMarker(ISerializationContext context, DisputableVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns EmendationVersMarker
	 *     AbstractMarker returns EmendationVersMarker
	 *     SentenceItemNoAmbivalence returns EmendationVersMarker
	 *     VersMarker returns EmendationVersMarker
	 *     EmendationVersMarker returns EmendationVersMarker
	 *
	 * Constraint:
	 *     {EmendationVersMarker}
	 */
	protected void sequence_EmendationVersMarker(ISerializationContext context, EmendationVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Emendation
	 *     Brackets returns Emendation
	 *     NoCartouche returns Emendation
	 *     Emendation returns Emendation
	 *     NoDisputableReading returns Emendation
	 *     NoLacuna returns Emendation
	 *     NoExpandedColumn returns Emendation
	 *     NoRasur returns Emendation
	 *     NoAncientExpanded returns Emendation
	 *     NoRestorationOverRasur returns Emendation
	 *     NoPartialDestruction returns Emendation
	 *
	 * Constraint:
	 *     wChar+=NoEmendation+
	 */
	protected void sequence_Emendation(ISerializationContext context, Emendation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns ExpandedColumn
	 *     Brackets returns ExpandedColumn
	 *     NoCartouche returns ExpandedColumn
	 *     NoDisputableReading returns ExpandedColumn
	 *     ExpandedColumn returns ExpandedColumn
	 *
	 * Constraint:
	 *     wChar+=NoExpandedColumn+
	 */
	protected void sequence_ExpandedColumn(ISerializationContext context, ExpandedColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoCartouche returns Expanded
	 *     Expanded returns Expanded
	 *     NoEmendation returns Expanded
	 *     NoDisputableReading returns Expanded
	 *     NoDeletion returns Expanded
	 *     NoExpandedColumn returns Expanded
	 *     NoRasur returns Expanded
	 *     NoAncientExpanded returns Expanded
	 *
	 * Constraint:
	 *     wChar+=NoExpanded+
	 */
	protected void sequence_Expanded(ISerializationContext context, Expanded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixCompoundWords
	 *     NoCartouche returns InterfixCompoundWords
	 *     NoExpanded returns InterfixCompoundWords
	 *     NoEmendation returns InterfixCompoundWords
	 *     NoDisputableReading returns InterfixCompoundWords
	 *     NoLacuna returns InterfixCompoundWords
	 *     NoDeletion returns InterfixCompoundWords
	 *     NoExpandedColumn returns InterfixCompoundWords
	 *     NoRasur returns InterfixCompoundWords
	 *     NoAncientExpanded returns InterfixCompoundWords
	 *     NoRestorationOverRasur returns InterfixCompoundWords
	 *     NoPartialDestruction returns InterfixCompoundWords
	 *     Interfix returns InterfixCompoundWords
	 *     InterfixCompoundWords returns InterfixCompoundWords
	 *
	 * Constraint:
	 *     {InterfixCompoundWords}
	 */
	protected void sequence_InterfixCompoundWords(ISerializationContext context, InterfixCompoundWords semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixConnectionSyllabicGroup
	 *     NoCartouche returns InterfixConnectionSyllabicGroup
	 *     NoExpanded returns InterfixConnectionSyllabicGroup
	 *     NoEmendation returns InterfixConnectionSyllabicGroup
	 *     NoDisputableReading returns InterfixConnectionSyllabicGroup
	 *     NoLacuna returns InterfixConnectionSyllabicGroup
	 *     NoDeletion returns InterfixConnectionSyllabicGroup
	 *     NoExpandedColumn returns InterfixConnectionSyllabicGroup
	 *     NoRasur returns InterfixConnectionSyllabicGroup
	 *     NoAncientExpanded returns InterfixConnectionSyllabicGroup
	 *     NoRestorationOverRasur returns InterfixConnectionSyllabicGroup
	 *     NoPartialDestruction returns InterfixConnectionSyllabicGroup
	 *     Interfix returns InterfixConnectionSyllabicGroup
	 *     InterfixConnectionSyllabicGroup returns InterfixConnectionSyllabicGroup
	 *
	 * Constraint:
	 *     {InterfixConnectionSyllabicGroup}
	 */
	protected void sequence_InterfixConnectionSyllabicGroup(ISerializationContext context, InterfixConnectionSyllabicGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixFlexion
	 *     NoCartouche returns InterfixFlexion
	 *     NoExpanded returns InterfixFlexion
	 *     NoEmendation returns InterfixFlexion
	 *     NoDisputableReading returns InterfixFlexion
	 *     NoLacuna returns InterfixFlexion
	 *     NoDeletion returns InterfixFlexion
	 *     NoExpandedColumn returns InterfixFlexion
	 *     NoRasur returns InterfixFlexion
	 *     NoAncientExpanded returns InterfixFlexion
	 *     NoRestorationOverRasur returns InterfixFlexion
	 *     NoPartialDestruction returns InterfixFlexion
	 *     Interfix returns InterfixFlexion
	 *     InterfixFlexion returns InterfixFlexion
	 *
	 * Constraint:
	 *     {InterfixFlexion}
	 */
	protected void sequence_InterfixFlexion(ISerializationContext context, InterfixFlexion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixLexical
	 *     NoCartouche returns InterfixLexical
	 *     NoExpanded returns InterfixLexical
	 *     NoEmendation returns InterfixLexical
	 *     NoDisputableReading returns InterfixLexical
	 *     NoLacuna returns InterfixLexical
	 *     NoDeletion returns InterfixLexical
	 *     NoExpandedColumn returns InterfixLexical
	 *     NoRasur returns InterfixLexical
	 *     NoAncientExpanded returns InterfixLexical
	 *     NoRestorationOverRasur returns InterfixLexical
	 *     NoPartialDestruction returns InterfixLexical
	 *     Interfix returns InterfixLexical
	 *     InterfixLexical returns InterfixLexical
	 *
	 * Constraint:
	 *     {InterfixLexical}
	 */
	protected void sequence_InterfixLexical(ISerializationContext context, InterfixLexical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixPhoneticalComplement
	 *     NoCartouche returns InterfixPhoneticalComplement
	 *     NoExpanded returns InterfixPhoneticalComplement
	 *     NoEmendation returns InterfixPhoneticalComplement
	 *     NoDisputableReading returns InterfixPhoneticalComplement
	 *     NoLacuna returns InterfixPhoneticalComplement
	 *     NoDeletion returns InterfixPhoneticalComplement
	 *     NoExpandedColumn returns InterfixPhoneticalComplement
	 *     NoRasur returns InterfixPhoneticalComplement
	 *     NoAncientExpanded returns InterfixPhoneticalComplement
	 *     NoRestorationOverRasur returns InterfixPhoneticalComplement
	 *     NoPartialDestruction returns InterfixPhoneticalComplement
	 *     Interfix returns InterfixPhoneticalComplement
	 *     InterfixPhoneticalComplement returns InterfixPhoneticalComplement
	 *
	 * Constraint:
	 *     {InterfixPhoneticalComplement}
	 */
	protected void sequence_InterfixPhoneticalComplement(ISerializationContext context, InterfixPhoneticalComplement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixPrefixLexical
	 *     NoCartouche returns InterfixPrefixLexical
	 *     NoExpanded returns InterfixPrefixLexical
	 *     NoEmendation returns InterfixPrefixLexical
	 *     NoDisputableReading returns InterfixPrefixLexical
	 *     NoLacuna returns InterfixPrefixLexical
	 *     NoDeletion returns InterfixPrefixLexical
	 *     NoExpandedColumn returns InterfixPrefixLexical
	 *     NoRasur returns InterfixPrefixLexical
	 *     NoAncientExpanded returns InterfixPrefixLexical
	 *     NoRestorationOverRasur returns InterfixPrefixLexical
	 *     NoPartialDestruction returns InterfixPrefixLexical
	 *     Interfix returns InterfixPrefixLexical
	 *     InterfixPrefixLexical returns InterfixPrefixLexical
	 *
	 * Constraint:
	 *     {InterfixPrefixLexical}
	 */
	protected void sequence_InterfixPrefixLexical(ISerializationContext context, InterfixPrefixLexical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixPrefixNonLexical
	 *     NoCartouche returns InterfixPrefixNonLexical
	 *     NoExpanded returns InterfixPrefixNonLexical
	 *     NoEmendation returns InterfixPrefixNonLexical
	 *     NoDisputableReading returns InterfixPrefixNonLexical
	 *     NoLacuna returns InterfixPrefixNonLexical
	 *     NoDeletion returns InterfixPrefixNonLexical
	 *     NoExpandedColumn returns InterfixPrefixNonLexical
	 *     NoRasur returns InterfixPrefixNonLexical
	 *     NoAncientExpanded returns InterfixPrefixNonLexical
	 *     NoRestorationOverRasur returns InterfixPrefixNonLexical
	 *     NoPartialDestruction returns InterfixPrefixNonLexical
	 *     Interfix returns InterfixPrefixNonLexical
	 *     InterfixPrefixNonLexical returns InterfixPrefixNonLexical
	 *
	 * Constraint:
	 *     {InterfixPrefixNonLexical}
	 */
	protected void sequence_InterfixPrefixNonLexical(ISerializationContext context, InterfixPrefixNonLexical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns InterfixSuffixPronomLexical
	 *     NoCartouche returns InterfixSuffixPronomLexical
	 *     NoExpanded returns InterfixSuffixPronomLexical
	 *     NoEmendation returns InterfixSuffixPronomLexical
	 *     NoDisputableReading returns InterfixSuffixPronomLexical
	 *     NoLacuna returns InterfixSuffixPronomLexical
	 *     NoDeletion returns InterfixSuffixPronomLexical
	 *     NoExpandedColumn returns InterfixSuffixPronomLexical
	 *     NoRasur returns InterfixSuffixPronomLexical
	 *     NoAncientExpanded returns InterfixSuffixPronomLexical
	 *     NoRestorationOverRasur returns InterfixSuffixPronomLexical
	 *     NoPartialDestruction returns InterfixSuffixPronomLexical
	 *     Interfix returns InterfixSuffixPronomLexical
	 *     InterfixSuffixPronomLexical returns InterfixSuffixPronomLexical
	 *
	 * Constraint:
	 *     {InterfixSuffixPronomLexical}
	 */
	protected void sequence_InterfixSuffixPronomLexical(ISerializationContext context, InterfixSuffixPronomLexical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Lacuna
	 *     Brackets returns Lacuna
	 *     NoCartouche returns Lacuna
	 *     NoDisputableReading returns Lacuna
	 *     Lacuna returns Lacuna
	 *     NoDeletion returns Lacuna
	 *     NoExpandedColumn returns Lacuna
	 *     NoRasur returns Lacuna
	 *     NoAncientExpanded returns Lacuna
	 *     NoRestorationOverRasur returns Lacuna
	 *
	 * Constraint:
	 *     wChar+=NoLacuna+
	 */
	protected void sequence_Lacuna(ISerializationContext context, Lacuna semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns Marker
	 *     AbstractMarker returns Marker
	 *     SentenceItemNoAmbivalence returns Marker
	 *     Marker returns Marker
	 *
	 * Constraint:
	 *     type=BETWEEN_HASHES
	 */
	protected void sequence_Marker(ISerializationContext context, Marker semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EgyDslPackage.Literals.MARKER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EgyDslPackage.Literals.MARKER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMarkerAccess().getTypeBETWEEN_HASHESTerminalRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns MissingVersMarker
	 *     AbstractMarker returns MissingVersMarker
	 *     SentenceItemNoAmbivalence returns MissingVersMarker
	 *     VersMarker returns MissingVersMarker
	 *     MissingVersMarker returns MissingVersMarker
	 *
	 * Constraint:
	 *     {MissingVersMarker}
	 */
	protected void sequence_MissingVersMarker(ISerializationContext context, MissingVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Oval
	 *     Brackets returns Oval
	 *     Oval returns Oval
	 *     NoLacuna returns Oval
	 *     NoPartialDestruction returns Oval
	 *
	 * Constraint:
	 *     wChar+=NoCartouche+
	 */
	protected void sequence_Oval(ISerializationContext context, Oval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns PartialDestroyedVersMarker
	 *     AbstractMarker returns PartialDestroyedVersMarker
	 *     SentenceItemNoAmbivalence returns PartialDestroyedVersMarker
	 *     VersMarker returns PartialDestroyedVersMarker
	 *     PartialDestroyedVersMarker returns PartialDestroyedVersMarker
	 *
	 * Constraint:
	 *     {PartialDestroyedVersMarker}
	 */
	protected void sequence_PartialDestroyedVersMarker(ISerializationContext context, PartialDestroyedVersMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns PartialDestruction
	 *     Brackets returns PartialDestruction
	 *     NoCartouche returns PartialDestruction
	 *     NoDisputableReading returns PartialDestruction
	 *     NoDeletion returns PartialDestruction
	 *     NoExpandedColumn returns PartialDestruction
	 *     NoRasur returns PartialDestruction
	 *     NoAncientExpanded returns PartialDestruction
	 *     NoRestorationOverRasur returns PartialDestruction
	 *     PartialDestruction returns PartialDestruction
	 *
	 * Constraint:
	 *     wChar+=NoPartialDestruction+
	 */
	protected void sequence_PartialDestruction(ISerializationContext context, PartialDestruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Rasur
	 *     Brackets returns Rasur
	 *     NoCartouche returns Rasur
	 *     NoDisputableReading returns Rasur
	 *     Rasur returns Rasur
	 *
	 * Constraint:
	 *     wChar+=NoRasur+
	 */
	protected void sequence_Rasur(ISerializationContext context, Rasur semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns RestorationOverRasurMarker
	 *     AbstractMarker returns RestorationOverRasurMarker
	 *     SentenceItemNoAmbivalence returns RestorationOverRasurMarker
	 *     VersMarker returns RestorationOverRasurMarker
	 *     RestorationOverRasurMarker returns RestorationOverRasurMarker
	 *
	 * Constraint:
	 *     {RestorationOverRasurMarker}
	 */
	protected void sequence_RestorationOverRasurMarker(ISerializationContext context, RestorationOverRasurMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns RestorationOverRasur
	 *     Brackets returns RestorationOverRasur
	 *     NoCartouche returns RestorationOverRasur
	 *     NoDisputableReading returns RestorationOverRasur
	 *     NoDeletion returns RestorationOverRasur
	 *     RestorationOverRasur returns RestorationOverRasur
	 *
	 * Constraint:
	 *     wChar+=NoRestorationOverRasur+
	 */
	protected void sequence_RestorationOverRasur(ISerializationContext context, RestorationOverRasur semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextItem returns Sentence
	 *     Sentence returns Sentence
	 *
	 * Constraint:
	 *     (items+=SentenceItem items+=SentenceItem*)?
	 */
	protected void sequence_Sentence(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMiddle returns Serech
	 *     Brackets returns Serech
	 *     Serech returns Serech
	 *     NoLacuna returns Serech
	 *     NoPartialDestruction returns Serech
	 *
	 * Constraint:
	 *     wChar+=NoCartouche+
	 */
	protected void sequence_Serech(ISerializationContext context, Serech semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextContent returns TextContent
	 *
	 * Constraint:
	 *     (items+=TextItem items+=TextItem*)
	 */
	protected void sequence_TextContent(ISerializationContext context, TextContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns VersFrontierMarker
	 *     AbstractMarker returns VersFrontierMarker
	 *     SentenceItemNoAmbivalence returns VersFrontierMarker
	 *     VersMarker returns VersFrontierMarker
	 *     VersFrontierMarker returns VersFrontierMarker
	 *
	 * Constraint:
	 *     {VersFrontierMarker}
	 */
	protected void sequence_VersFrontierMarker(ISerializationContext context, VersFrontierMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns VersbreakMarker
	 *     AbstractMarker returns VersbreakMarker
	 *     SentenceItemNoAmbivalence returns VersbreakMarker
	 *     VersMarker returns VersbreakMarker
	 *     VersbreakMarker returns VersbreakMarker
	 *
	 * Constraint:
	 *     {VersbreakMarker}
	 */
	protected void sequence_VersbreakMarker(ISerializationContext context, VersbreakMarker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordPart returns WordPart
	 *
	 * Constraint:
	 *     wChar=WordMiddle
	 */
	protected void sequence_WordPart(ISerializationContext context, WordPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EgyDslPackage.Literals.WORD_PART__WCHAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EgyDslPackage.Literals.WORD_PART__WCHAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWordPartAccess().getWCharWordMiddleParserRuleCall_0(), semanticObject.getWChar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenceItem returns Word
	 *     SentenceItemNoAmbivalence returns Word
	 *     Word returns Word
	 *
	 * Constraint:
	 *     wChar+=WordPart+
	 */
	protected void sequence_Word(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
